<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mission Control v5</title>
<style>
:root {
  --bg: #09090b;
  --bg2: #111118;
  --bg3: #1a1a24;
  --atlas: #00f3ff;
  --forge: #ff9d00;
  --lens: #bd00ff;
  --green: #00ff9d;
  --red: #ff0055;
  --amber: #ffc14d;
  --text: #e0e6ed;
  --text2: #8b9bb4;
  --text3: #4a5568;
  --border: #1e2433;
  --font-mono: "Courier New", monospace;
  --font: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  background: radial-gradient(circle at 10% -20%, #162033 0%, var(--bg) 40%), var(--bg);
  color: var(--text);
  font-family: var(--font);
  height: 100vh;
  display: grid;
  grid-template-rows: auto 1fr;
  overflow: hidden;
}

header {
  background: var(--bg2);
  border-bottom: 1px solid var(--border);
  padding: 10px 14px;
  display: grid;
  gap: 10px;
}
.header-row { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
.brand { font-family: var(--font-mono); letter-spacing: 2px; font-weight: 700; color: var(--atlas); }
.status-line { font-family: var(--font-mono); font-size: 0.74rem; color: var(--text2); display: flex; gap: 14px; flex-wrap: wrap; }
.status-pill { display: inline-flex; align-items: center; gap: 6px; }
.dot { width: 8px; height: 8px; border-radius: 50%; background: var(--text3); }
.dot.on { background: var(--green); box-shadow: 0 0 9px var(--green); }
.dot.off { background: var(--red); }
.dot.checking { background: var(--amber); box-shadow: 0 0 9px rgba(255, 193, 77, 0.45); }

main {
  display: grid;
  grid-template-columns: 320px 1fr 360px;
  background: var(--border);
  gap: 1px;
  overflow: hidden;
}
.col { background: var(--bg); overflow: hidden; display: flex; flex-direction: column; }

.panel-head {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  background: var(--bg2);
  font-family: var(--font-mono);
  font-size: 0.72rem;
  letter-spacing: 0.08em;
  color: var(--text3);
  text-transform: uppercase;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.queue-wrap { flex: 1; display: flex; flex-direction: column; min-height: 0; }
.queue-add { padding: 10px; border-bottom: 1px solid var(--border); display: grid; gap: 8px; }
textarea, input, button {
  font: inherit;
}
#queue-input, #mission-input, #history-filter {
  width: 100%;
  background: var(--bg2);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 10px;
  outline: none;
}
#queue-input:focus, #mission-input:focus, #history-filter:focus { border-color: var(--atlas); }
.btn-row { display: flex; gap: 8px; }
.btn {
  border: 1px solid var(--border);
  color: var(--text);
  background: var(--bg2);
  border-radius: 8px;
  padding: 8px 10px;
  font-size: 0.78rem;
  cursor: pointer;
  font-weight: 700;
}
.btn.primary { background: linear-gradient(135deg, var(--atlas), #0088aa); color: #000; border-color: #0088aa; }
.btn.warn { border-color: var(--red); color: var(--red); background: rgba(255, 0, 85, 0.12); }
.btn.ghost { border-color: var(--text3); color: var(--text2); }
.btn:disabled { opacity: 0.45; cursor: not-allowed; }

.queue-list { flex: 1; overflow-y: auto; padding: 8px; display: grid; gap: 8px; }
.queue-item {
  border: 1px solid var(--border);
  border-left: 3px solid var(--text3);
  border-radius: 8px;
  padding: 8px;
  background: var(--bg2);
}
.queue-item.pending { border-left-color: var(--text3); }
.queue-item.running { border-left-color: var(--amber); animation: pulse 1.1s infinite; }
.queue-item.done { border-left-color: var(--green); }
.queue-item.failed { border-left-color: var(--red); }
.queue-meta { font-size: 0.68rem; color: var(--text2); margin-top: 4px; font-family: var(--font-mono); display: flex; justify-content: space-between; }

.memory-wrap { border-top: 1px solid var(--border); height: 38%; min-height: 220px; display: flex; flex-direction: column; }
.memory-tabs { display: flex; gap: 6px; padding: 8px 10px; border-bottom: 1px solid var(--border); }
.memory-tab { flex: 1; text-align: center; padding: 6px; border-radius: 6px; border: 1px solid var(--border); background: var(--bg2); color: var(--text2); cursor: pointer; font-size: 0.72rem; font-family: var(--font-mono); }
.memory-tab.active { color: var(--text); border-color: var(--atlas); }
#memory-list { flex: 1; overflow-y: auto; padding: 8px 10px; font-size: 0.77rem; }
.memory-item { border-bottom: 1px solid var(--border); padding: 8px 0; }
.memory-meta { color: var(--text3); font-family: var(--font-mono); font-size: 0.68rem; margin-bottom: 4px; }
.memory-actions { padding: 8px 10px; border-top: 1px solid var(--border); }

.center-top { padding: 10px; border-bottom: 1px solid var(--border); background: var(--bg2); display: grid; gap: 8px; }
.agent-strip { display: flex; gap: 10px; flex-wrap: wrap; font-family: var(--font-mono); font-size: 0.72rem; }
.agent-chip { display: flex; align-items: center; gap: 6px; }
.mode-row { display: flex; gap: 6px; align-items: center; }
.mode { border: 1px solid var(--border); background: transparent; color: var(--text2); border-radius: 14px; padding: 4px 10px; cursor: pointer; font-size: 0.72rem; }
.mode.active { color: var(--text); border-color: var(--atlas); background: rgba(0,243,255,0.08); }

.log-area { flex: 1; overflow-y: auto; padding: 10px; font-family: var(--font-mono); font-size: 0.78rem; }
.log-line { margin-bottom: 4px; line-height: 1.45; }
.log-ts { color: var(--text3); margin-right: 8px; }
.log-sys { color: var(--green); }
.log-atlas { color: var(--atlas); }
.log-forge { color: var(--forge); }
.log-lens { color: var(--lens); }
.log-err { color: var(--red); }
.log-tool { color: #ffe066; }

.tool-panel { border-top: 1px solid var(--border); max-height: 180px; overflow-y: auto; }
.tool-item { border-bottom: 1px solid var(--border); padding: 8px 10px; font-family: var(--font-mono); font-size: 0.74rem; }
.tool-path { color: var(--atlas); margin-bottom: 5px; }
.tool-code { color: var(--text2); white-space: pre-wrap; }
.tool-badge { color: var(--text2); font-size: 0.72rem; }
.handoff-box { border-top: 1px solid var(--border); padding: 8px 10px; display: grid; gap: 8px; }
#handoff-status { font-family: var(--font-mono); font-size: 0.74rem; color: var(--text2); white-space: pre-wrap; }

.history-wrap { flex: 1; overflow: hidden; display: flex; flex-direction: column; }
.history-tools { padding: 10px; border-bottom: 1px solid var(--border); }
.history-list { flex: 1; overflow-y: auto; }
.history-item { padding: 10px; border-bottom: 1px solid var(--border); cursor: pointer; transition: background 0.2s; }
.history-item:hover { background: var(--bg2); }
.history-title { font-size: 0.82rem; font-weight: 700; margin-bottom: 5px; }
.history-meta { display: flex; justify-content: space-between; gap: 6px; flex-wrap: wrap; font-family: var(--font-mono); font-size: 0.68rem; color: var(--text2); }
.badge { padding: 1px 6px; border-radius: 999px; font-weight: 700; }
.badge.high { background: rgba(0,255,157,.15); color: var(--green); }
.badge.mid { background: rgba(255,157,0,.15); color: var(--forge); }
.badge.low { background: rgba(255,0,85,.15); color: var(--red); }

.modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.66);
  display: none;
  align-items: center;
  justify-content: center;
  padding: 12px;
  z-index: 9;
}
.modal.open { display: flex; }
.modal-box {
  width: min(980px, 100%);
  max-height: 95vh;
  overflow-y: auto;
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 12px;
}
.modal-head { position: sticky; top: 0; background: var(--bg2); border-bottom: 1px solid var(--border); padding: 12px; display: flex; justify-content: space-between; align-items: center; gap: 10px; }
.modal-body { padding: 12px; display: grid; gap: 10px; }
.detail-box { border: 1px solid var(--border); border-radius: 10px; overflow: hidden; }
.detail-head { padding: 8px 10px; background: var(--bg3); border-bottom: 1px solid var(--border); font-family: var(--font-mono); font-size: .72rem; color: var(--text2); display:flex;justify-content:space-between;align-items:center; }
pre { margin: 0; padding: 10px; white-space: pre-wrap; word-break: break-word; font-family: var(--font-mono); font-size: 0.77rem; color: var(--text); }
.code-kw { color: #76f5c0; }
.code-str { color: #ffd479; }
.code-num { color: #7ad7ff; }
.code-cmt { color: #7a879e; }
.verdict-line { font-family: var(--font-mono); font-size: .78rem; }

.right-tabs {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 6px;
  padding: 10px;
  border-bottom: 1px solid var(--border);
  background: var(--bg2);
}
.right-tab {
  border: 1px solid var(--border);
  border-radius: 8px;
  background: var(--bg);
  color: var(--text2);
  font-family: var(--font-mono);
  font-size: 0.7rem;
  padding: 8px 6px;
  cursor: pointer;
  text-transform: uppercase;
}
.right-tab.active {
  color: var(--text);
  border-color: var(--atlas);
  background: rgba(0,243,255,0.08);
}
.right-body {
  min-height: 0;
  height: 56%;
  display: flex;
  flex-direction: column;
}
.right-pane {
  display: none;
  flex: 1;
  min-height: 0;
  overflow-y: auto;
}
.right-pane.active {
  display: flex;
  flex-direction: column;
}
.live-output-wrap,
.team-wrap,
.report-wrap {
  padding: 10px;
  display: grid;
  gap: 10px;
}
.live-output-box,
.team-card,
.report-panel {
  border: 1px solid var(--border);
  border-radius: 10px;
  background: var(--bg2);
}
.live-output-box {
  overflow: hidden;
  min-height: 220px;
  display: flex;
  flex-direction: column;
}
.live-output-head {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  background: var(--bg3);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}
.live-output-title {
  font-family: var(--font-mono);
  font-size: 0.72rem;
  color: var(--text2);
  text-transform: uppercase;
}
#live-output-text {
  flex: 1;
  margin: 0;
  padding: 12px;
  overflow-y: auto;
  min-height: 180px;
}
.report-panel {
  display: none;
  padding: 14px;
}
.report-empty {
  color: var(--text3);
  font-size: 0.78rem;
  padding: 12px;
  border: 1px dashed var(--border);
  border-radius: 8px;
  text-align: center;
}
.report-panel.show { display: grid; gap: 12px; }
.report-head {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 10px;
  flex-wrap: wrap;
}
.report-title {
  font-family: var(--font-mono);
  letter-spacing: 0.08em;
  color: var(--text2);
  text-transform: uppercase;
  font-size: 0.72rem;
}
.report-ts {
  font-size: 0.72rem;
  color: var(--text3);
  font-family: var(--font-mono);
}
.report-verdict-badge {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  border-radius: 999px;
  padding: 8px 14px;
  font-weight: 800;
  font-family: var(--font-mono);
  width: fit-content;
}
.report-verdict-badge.ship { color: var(--green); background: rgba(0,255,157,0.12); border: 1px solid rgba(0,255,157,0.25); }
.report-verdict-badge.no-ship { color: var(--red); background: rgba(255,0,85,0.12); border: 1px solid rgba(255,0,85,0.25); }
.report-time {
  display: grid;
  gap: 4px;
}
.report-time-big {
  font-size: 2rem;
  line-height: 1;
  font-weight: 900;
}
.report-time-label {
  color: var(--text3);
  font-size: 0.72rem;
  font-family: var(--font-mono);
  text-transform: uppercase;
}
.report-section-label {
  font-size: 0.7rem;
  font-family: var(--font-mono);
  color: var(--text3);
  text-transform: uppercase;
  letter-spacing: 0.08em;
}
.report-stats-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.78rem;
}
.report-stats-table th,
.report-stats-table td {
  text-align: left;
  padding: 8px 6px;
  border-bottom: 1px solid var(--border);
}
.report-stats-table th {
  color: var(--text3);
  font-family: var(--font-mono);
  font-size: 0.68rem;
}
.report-stats-table td {
  color: var(--text2);
}
.report-code-box {
  border: 1px solid var(--border);
  border-radius: 8px;
  overflow: hidden;
  background: var(--bg);
}
.report-code-head {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  padding: 8px 10px;
  border-bottom: 1px solid var(--border);
  background: var(--bg3);
}
#report-forge-output {
  max-height: 260px;
  overflow-y: auto;
}
.report-issues-list {
  list-style: none;
  display: grid;
  gap: 8px;
}
.report-issues-list li {
  color: var(--red);
  background: rgba(255,0,85,0.08);
  border: 1px solid rgba(255,0,85,0.18);
  border-radius: 8px;
  padding: 8px 10px;
  font-size: 0.78rem;
}
.report-footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  flex-wrap: wrap;
}
.team-grid {
  display: grid;
  gap: 10px;
}
.team-card {
  padding: 12px;
  position: relative;
  overflow: hidden;
}
.team-card.active::after {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.04), transparent);
  animation: sweep 1.6s linear infinite;
}
.team-head {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  margin-bottom: 10px;
}
.team-name {
  font-weight: 800;
  letter-spacing: 0.04em;
}
.team-role {
  color: var(--text3);
  font-size: 0.72rem;
  font-family: var(--font-mono);
}
.team-status {
  display: inline-flex;
  align-items: center;
  gap: 7px;
  font-family: var(--font-mono);
  font-size: 0.72rem;
  text-transform: uppercase;
}
.pulse-dot {
  width: 9px;
  height: 9px;
  border-radius: 50%;
  background: var(--text3);
}
.pulse-dot.live {
  animation: pulse 1s infinite;
}
.pulse-dot.idle { background: var(--text3); }
.pulse-dot.thinking { background: var(--amber); box-shadow: 0 0 10px rgba(255,193,77,0.5); }
.pulse-dot.working { background: var(--atlas); box-shadow: 0 0 10px rgba(0,243,255,0.45); }
.team-meta {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 8px;
}
.team-stat {
  border: 1px solid var(--border);
  border-radius: 8px;
  background: var(--bg);
  padding: 8px;
}
.team-stat-label {
  color: var(--text3);
  font-size: 0.66rem;
  font-family: var(--font-mono);
  text-transform: uppercase;
  margin-bottom: 4px;
}
.team-stat-value {
  color: var(--text);
  font-size: 0.8rem;
}

@keyframes sweep {
  from { transform: translateX(-100%); }
  to { transform: translateX(100%); }
}

@keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.55; } }
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }

@media (max-width: 1100px) {
  main { grid-template-columns: 1fr; grid-template-rows: auto auto auto; overflow-y: auto; }
  body { height: auto; min-height: 100vh; overflow: auto; }
  .memory-wrap { height: 260px; }
  .right-body { height: auto; }
}
</style>
</head>
<body>
<header>
  <div class="header-row">
    <div class="brand">MISSION CONTROL v5</div>
    <div class="status-line">
      <span class="status-pill"><span class="dot" id="dot-pc1"></span>PC1 <span id="pc1-text">checking</span></span>
      <span class="status-pill"><span class="dot" id="dot-pc2"></span>PC2 <span id="pc2-text">checking</span></span>
      <span class="status-pill">TOOLS: <span class="dot checking" id="dot-tool"></span> <span id="tool-text">checking</span></span>
    </div>
  </div>
  <div class="status-line" id="stats-line">
    <span>Total: 0</span>
    <span>Avg: ‚Äî</span>
    <span>Tokens: 0</span>
    <span>Uptime: 0s</span>
  </div>
</header>

<main>
  <section class="col">
    <div class="queue-wrap">
      <div class="panel-head">Mission Queue <span id="queue-count">0</span></div>
      <div class="queue-add">
        <textarea id="queue-input" rows="2" placeholder="Queue a mission..."></textarea>
        <div class="btn-row">
          <button class="btn" onclick="addMissionToQueue()">Add Queue</button>
          <button class="btn primary" id="btn-dispatch" onclick="dispatchNow()">Dispatch Now</button>
          <button class="btn warn" id="btn-abort" onclick="abortMission()" disabled>Abort</button>
        </div>
      </div>
      <div class="queue-list" id="queue-list"></div>
    </div>

    <div class="memory-wrap">
      <div class="panel-head">Agent Memory</div>
      <div class="memory-tabs">
        <button class="memory-tab active" id="tab-atlas" onclick="setMemoryTab('atlas')">Atlas</button>
        <button class="memory-tab" id="tab-forge" onclick="setMemoryTab('forge')">Forge</button>
        <button class="memory-tab" id="tab-lens" onclick="setMemoryTab('lens')">Lens</button>
      </div>
      <div id="memory-list"></div>
      <div class="memory-actions"><button class="btn ghost" onclick="clearAgentMemory()">Clear Current Agent</button></div>
    </div>
  </section>

  <section class="col">
    <div class="center-top">
      <textarea id="mission-input" rows="2" placeholder="Single mission input... (Enter dispatches)"></textarea>
      <div class="btn-row">
        <button class="btn" onclick="addMissionToQueue('mission-input')">Add From Input</button>
      </div>
      <div class="mode-row">
        <span style="font-size:.72rem;color:var(--text3)">Mode:</span>
        <button class="mode active" id="mode-full" onclick="setMode('full')">Full Pipeline</button>
        <button class="mode" id="mode-forge-only" onclick="setMode('forge-only')">Forge Only</button>
        <button class="mode" id="mode-atlas-only" onclick="setMode('atlas-only')">Atlas Only</button>
      </div>
      <div class="agent-strip">
        <span class="agent-chip"><span class="dot" id="dot-atlas"></span>ATLAS</span>
        <span class="agent-chip"><span class="dot" id="dot-forge"></span>FORGE</span>
        <span class="agent-chip"><span class="dot" id="dot-lens"></span>LENS</span>
      </div>
    </div>
    <div class="log-area" id="log"></div>
    <div class="panel-head">Tool Output <span id="tool-count">0</span></div>
    <div class="tool-panel" id="tool-output"></div>
    <div class="handoff-box">
      <div class="btn-row">
        <button class="btn primary" id="btn-codex-handoff" onclick="runCodexHandoff()" style="display:none">‚ñ∂ Run in Codex CLI</button>
      </div>
      <div id="handoff-status"></div>
    </div>
  </section>

  <section class="col">
    <div class="right-tabs">
      <button class="right-tab active" id="right-tab-live" onclick="switchRightTab('live')">Live Output</button>
      <button class="right-tab" id="right-tab-report" onclick="switchRightTab('report')">Report</button>
      <button class="right-tab" id="right-tab-team" onclick="switchRightTab('team')">Team</button>
    </div>

    <div class="right-body">
      <div class="right-pane active" id="right-pane-live">
        <div class="live-output-wrap">
          <div class="live-output-box">
            <div class="live-output-head">
              <div class="live-output-title" id="live-output-title">Live Output</div>
              <button class="btn ghost" onclick="copyLiveOutput()">Copy</button>
            </div>
            <pre id="live-output-text">Waiting for mission...</pre>
          </div>
        </div>
      </div>

      <div class="right-pane" id="right-pane-report">
        <div class="report-wrap">
          <div class="report-empty" id="report-empty">Mission report appears here after a run completes.</div>
          <div class="report-panel" id="mission-report">
            <div class="report-head">
              <div>
                <div class="report-title">Mission Report</div>
                <div class="report-ts" id="report-timestamp">--</div>
              </div>
              <div class="report-verdict-badge ship" id="report-verdict">SHIP</div>
            </div>

            <div class="report-time">
              <div class="report-time-big" id="report-elapsed">0.0s</div>
              <div class="report-time-label">Total Elapsed Time</div>
            </div>

            <div class="report-section-label">Per-Agent Stats</div>
            <table class="report-stats-table">
              <thead>
                <tr>
                  <th>Agent</th>
                  <th>Tokens</th>
                  <th>TPS</th>
                  <th>Time</th>
                </tr>
              </thead>
              <tbody id="report-stats-body"></tbody>
            </table>

            <div class="report-section-label">Forge Final Output</div>
            <div class="report-code-box">
              <div class="report-code-head">
                <span>forge.output</span>
                <button class="btn ghost" onclick="copyReportForgeOutput()">Copy</button>
              </div>
              <pre id="report-forge-output"></pre>
            </div>

            <div id="report-issues-block">
              <div class="report-section-label">Lens Issues</div>
              <ul class="report-issues-list" id="report-issues"></ul>
            </div>

            <div class="report-footer">
              <div class="report-ts" id="report-footer-ts">--</div>
              <button class="btn" onclick="downloadMissionReport()">Download Report JSON</button>
            </div>
          </div>
        </div>
      </div>

      <div class="right-pane" id="right-pane-team">
        <div class="team-wrap">
          <div class="team-grid" id="team-grid">
            <div class="team-card" id="team-atlas"></div>
            <div class="team-card" id="team-forge"></div>
            <div class="team-card" id="team-lens"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="history-wrap">
      <div class="panel-head">Mission History (<span id="history-count">0</span>)</div>
      <div class="history-tools">
        <input id="history-filter" placeholder="Search mission/task/verdict..." oninput="renderHistory()">
      </div>
      <div class="history-list" id="history-list"></div>
    </div>
  </section>
</main>

<div class="modal" id="detail-modal" onclick="if(event.target===this)closeMissionDetail()">
  <div class="modal-box">
    <div class="modal-head">
      <div id="detail-title" style="font-weight:700"></div>
      <div class="btn-row">
        <button class="btn" onclick="rerunMission()">Re-run Mission</button>
        <button class="btn primary" onclick="exportToCodex()">Export ‚Üí Codex</button>
        <button class="btn ghost" onclick="closeMissionDetail()">Close</button>
      </div>
    </div>
    <div class="modal-body">
      <div class="verdict-line" id="detail-summary"></div>

      <details class="detail-box" open>
        <summary class="detail-head"><span>Atlas Plan</span></summary>
        <pre id="detail-atlas"></pre>
      </details>

      <div class="detail-box">
        <div class="detail-head"><span>Forge Output</span><button class="btn ghost" onclick="copyForgeOutput()">Copy</button></div>
        <pre id="detail-forge"></pre>
      </div>

      <div class="detail-box">
        <div class="detail-head"><span>Lens Verdict</span></div>
        <pre id="detail-lens"></pre>
      </div>
    </div>
  </div>
</div>

<script>
const TOOL_SERVER = 'http://100.90.212.55:7777';
const PC1_ENDPOINT = 'http://100.90.212.55:8080';
const PC2_ENDPOINT = 'http://100.122.180.1:11434';
const HISTORY_KEY = 'mc4_missions';
const QUEUE_KEY = 'mc4_queue';
const MEMORY_KEY = 'mc4_agent_memory';

const AGENTS = {
  atlas: {
    endpoint: PC2_ENDPOINT,
    api: 'ollama',
    model: 'qwen3:8b',
    maxTokens: 550,
    temp: 0.7,
    ctx: 8192,
    system: `You are Atlas, planner for Mission Control. Produce concise and executable plans in 2-6 steps.\nReturn JSON array only. Example: [{"step":1,"action":"...","assignee":"forge","context":"..."}]`
  },
  forge: {
    endpoint: PC1_ENDPOINT,
    api: 'openai',
    model: 'qwen3.5-35b-a3b',
    maxTokens: 2200,
    temp: 0.7,
    ctx: 32768,
    system: `You are Forge, implementation specialist. Build complete output with no placeholders.\nAvailable tags: <TOOL:WRITE_FILE path="file">content</TOOL> <TOOL:WEB_SEARCH query="..."/> <TOOL:RUN_PYTHON>code</TOOL>.`
  },
  lens: {
    endpoint: PC2_ENDPOINT,
    api: 'ollama',
    model: 'qwen3:8b',
    maxTokens: 550,
    temp: 0.6,
    ctx: 8192,
    system: `You are Lens, strict reviewer. Output JSON only: {"verdict":"SHIP|NO_SHIP","score":1-10,"issues":[],"improvements":[],"feedback":"..."}`
  }
};

let mode = 'full';
let running = false;
let abortCtrl = null;
let missionStart = 0;
let totalTokensCurrent = 0;
let missionQueue = readJson(localStorage.getItem(QUEUE_KEY), []);
let localMissions = readJson(localStorage.getItem(HISTORY_KEY), []);
let allMissions = [];
let selectedMission = null;
let toolOutputs = 0;
let activeMemoryTab = 'atlas';
let startedAt = Date.now();
let missionSystemPrompts = { atlas: AGENTS.atlas.system, forge: AGENTS.forge.system, lens: AGENTS.lens.system };
let lastForgeSummary = '';
let lastMissionScore = 0;
let activeRightTab = 'live';
let liveOutputState = { agent: 'system', text: 'Waiting for mission...' };
let currentMissionReport = null;
let teamState = {
  atlas: { status: 'idle', lastActivity: 'Awaiting mission', model: AGENTS.atlas.model, tps: '‚Äî', route: 'PC2' },
  forge: { status: 'idle', lastActivity: 'Awaiting mission', model: AGENTS.forge.model, tps: '‚Äî', route: 'PC1' },
  lens: { status: 'idle', lastActivity: 'Awaiting mission', model: AGENTS.lens.model, tps: '‚Äî', route: 'PC2' }
};

let agentMemory = readJson(localStorage.getItem(MEMORY_KEY), { atlas: [], forge: [], lens: [] });

function readJson(raw, fallback) { try { return raw ? JSON.parse(raw) : fallback; } catch { return fallback; } }
function escHtml(s) { return String(s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }
function uid(prefix='mission') { return `${prefix}-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`; }
function uuid() { return (crypto?.randomUUID?.() || uid('uuid')); }
function slugify(s) { return String(s || 'mission').toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '').slice(0, 60) || 'mission'; }
function normalizeLessons(items) {
  if (!Array.isArray(items)) return [];
  return items
    .map((x) => (typeof x === 'string' ? x : x?.content))
    .filter((x) => typeof x === 'string' && x.trim())
    .map((x) => x.trim());
}
function lessonsBlock(agent) {
  const lessons = normalizeLessons(agentMemory[agent]);
  if (!lessons.length) return '';
  return `\n\n## Lessons learned:\n${lessons.join('\n')}`;
}
function rebuildMissionPrompts() {
  missionSystemPrompts = {
    atlas: AGENTS.atlas.system + lessonsBlock('atlas'),
    forge: AGENTS.forge.system + lessonsBlock('forge'),
    lens: AGENTS.lens.system + lessonsBlock('lens')
  };
}
function summarizeForgeOutput(text) {
  return String(text || '')
    .replace(/<TOOL:[^>]+>/g, ' ')
    .replace(/<\/TOOL>/g, ' ')
    .replace(/\s+/g, ' ')
    .trim()
    .slice(0, 900);
}
function setHandoffStatus(msg) {
  document.getElementById('handoff-status').textContent = msg || '';
}
function setCodexHandoffAvailability(score, forgeText='') {
  const btn = document.getElementById('btn-codex-handoff');
  lastMissionScore = Number(score || 0);
  lastForgeSummary = summarizeForgeOutput(forgeText);
  if (lastMissionScore >= 7 && lastForgeSummary) {
    btn.style.display = '';
    btn.disabled = false;
    setHandoffStatus('');
    return;
  }
  btn.style.display = 'none';
  setHandoffStatus(lastMissionScore > 0 ? 'Needs revision ‚Äî retry?' : '');
}
function setToolStatus(state) {
  const dot = document.getElementById('dot-tool');
  dot.classList.remove('on', 'off', 'checking');
  if (state === 'connected') {
    dot.classList.add('on');
    document.getElementById('tool-text').textContent = '‚óè connected';
    return;
  }
  if (state === 'offline') {
    dot.classList.add('off');
    document.getElementById('tool-text').textContent = '‚óã offline';
    return;
  }
  dot.classList.add('checking');
  document.getElementById('tool-text').textContent = 'checking';
}

function log(agent, msg, type='') {
  const el = document.getElementById('log');
  const ts = new Date().toLocaleTimeString('en-US', { hour12: false });
  const row = document.createElement('div');
  const cls = type || `log-${agent}`;
  row.className = 'log-line';
  row.innerHTML = `<span class="log-ts">${ts}</span><span class="${cls}">[${agent.toUpperCase()}]</span> ${escHtml(msg)}`;
  el.appendChild(row);
  el.scrollTop = el.scrollHeight;
  if (teamState[agent]) {
    updateTeamCard(agent, { lastActivity: `${ts} ¬∑ ${String(msg).slice(0, 44)}` });
  }
}

function setDot(id, state) {
  const el = document.getElementById(id);
  el.classList.remove('on', 'off');
  if (state === 'on') el.classList.add('on');
  if (state === 'off') el.classList.add('off');
}

function setMode(next) {
  mode = next;
  document.querySelectorAll('.mode').forEach((b) => b.classList.remove('active'));
  document.getElementById(`mode-${next}`).classList.add('active');
}

function switchRightTab(tab) {
  activeRightTab = tab;
  ['live', 'report', 'team'].forEach((name) => {
    document.getElementById(`right-tab-${name}`).classList.toggle('active', name === tab);
    document.getElementById(`right-pane-${name}`).classList.toggle('active', name === tab);
  });
}

function setLiveOutput(agent, text) {
  liveOutputState = { agent: agent || 'system', text: String(text || '') };
  const label = agent ? `${agent.toUpperCase()} ¬∑ Live Output` : 'Live Output';
  document.getElementById('live-output-title').textContent = label;
  document.getElementById('live-output-text').textContent = liveOutputState.text || 'Waiting for mission...';
}

function copyLiveOutput() {
  navigator.clipboard.writeText(document.getElementById('live-output-text').textContent || '').catch(() => {});
}

function updateTeamCard(agent, patch = {}) {
  if (!teamState[agent]) return;
  teamState[agent] = { ...teamState[agent], ...patch };
  const cfg = teamState[agent];
  const active = cfg.status === 'thinking' || cfg.status === 'working';
  const target = document.getElementById(`team-${agent}`);
  target.className = `team-card${active ? ' active' : ''}`;
  target.innerHTML = `
    <div class="team-head">
      <div>
        <div class="team-name">${agent.toUpperCase()}</div>
        <div class="team-role">${cfg.route} Routing</div>
      </div>
      <div class="team-status">
        <span class="pulse-dot ${cfg.status} ${active ? 'live' : ''}"></span>
        <span>${escHtml(cfg.status)}</span>
      </div>
    </div>
    <div class="team-meta">
      <div class="team-stat">
        <div class="team-stat-label">Last Activity</div>
        <div class="team-stat-value">${escHtml(cfg.lastActivity)}</div>
      </div>
      <div class="team-stat">
        <div class="team-stat-label">Model + TPS</div>
        <div class="team-stat-value">${escHtml(cfg.model)} ¬∑ ${escHtml(String(cfg.tps))}</div>
      </div>
      <div class="team-stat">
        <div class="team-stat-label">PC Routing</div>
        <div class="team-stat-value">${escHtml(cfg.route)}</div>
      </div>
      <div class="team-stat">
        <div class="team-stat-label">Current Status</div>
        <div class="team-stat-value">${escHtml(cfg.status)}</div>
      </div>
    </div>`;
}

function renderTeamPanel() {
  ['atlas', 'forge', 'lens'].forEach((agent) => updateTeamCard(agent));
}

function setAgentPresence(agent, status, lastActivity, metrics = null) {
  if (!teamState[agent]) return;
  updateTeamCard(agent, {
    status,
    lastActivity,
    tps: metrics?.tps ? `${metrics.tps} TPS` : teamState[agent].tps,
    model: AGENTS[agent]?.model || teamState[agent].model
  });
}

function renderMissionReport(report) {
  currentMissionReport = report;
  const panel = document.getElementById('mission-report');
  const empty = document.getElementById('report-empty');
  empty.style.display = 'none';
  panel.classList.add('show');
  document.getElementById('report-timestamp').textContent = report.timestamp;
  document.getElementById('report-footer-ts').textContent = report.timestamp;
  const badge = document.getElementById('report-verdict');
  badge.className = `report-verdict-badge ${report.verdict === 'SHIP' ? 'ship' : 'no-ship'}`;
  badge.textContent = report.verdict === 'SHIP' ? 'SHIP' : 'NO-SHIP';
  document.getElementById('report-elapsed').textContent = `${report.elapsed}s`;

  const body = document.getElementById('report-stats-body');
  body.innerHTML = '';
  report.agentStats.forEach((row) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${escHtml(row.agent)}</td><td>${escHtml(String(row.tokens))}</td><td>${escHtml(String(row.tps))}</td><td>${escHtml(String(row.time))}</td>`;
    body.appendChild(tr);
  });

  document.getElementById('report-forge-output').textContent = report.forgeOutput || '(none)';
  const issues = document.getElementById('report-issues');
  const issueBlock = document.getElementById('report-issues-block');
  if (report.issues.length) {
    issueBlock.style.display = '';
    issues.innerHTML = report.issues.map((item) => `<li>${escHtml(item)}</li>`).join('');
  } else {
    issueBlock.style.display = 'none';
    issues.innerHTML = '';
  }
}

function copyReportForgeOutput() {
  navigator.clipboard.writeText(document.getElementById('report-forge-output').textContent || '').catch(() => {});
}

function downloadMissionReport() {
  if (!currentMissionReport) return;
  const blob = new Blob([JSON.stringify(currentMissionReport, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `mission-report-${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

function resetMissionPanels() {
  setLiveOutput('system', 'Waiting for mission...');
  currentMissionReport = null;
  document.getElementById('mission-report').classList.remove('show');
  document.getElementById('report-empty').style.display = '';
  document.getElementById('report-stats-body').innerHTML = '';
  document.getElementById('report-forge-output').textContent = '';
  document.getElementById('report-issues').innerHTML = '';
  document.getElementById('report-issues-block').style.display = 'none';
  ['atlas', 'forge', 'lens'].forEach((agent) => setAgentPresence(agent, 'idle', 'Awaiting mission', { tps: null }));
}

function saveQueue() {
  localStorage.setItem(QUEUE_KEY, JSON.stringify(missionQueue));
  syncQueueToToolServer();
}

async function syncQueueToToolServer() {
  try {
    await executeTool('write_file', { path: 'mission-queue.json', content: JSON.stringify(missionQueue, null, 2) });
  } catch {}
}

function addMissionToQueue(sourceId='queue-input') {
  const input = document.getElementById(sourceId);
  const task = input.value.trim();
  if (!task) return;
  missionQueue.push({
    id: uid('q'),
    missionId: uuid(),
    task,
    status: 'pending',
    createdAt: new Date().toISOString(),
    score: null,
    elapsed: null,
    tokens: 0
  });
  input.value = '';
  saveQueue();
  renderQueue();
  if (!running) runNextFromQueue();
}

function renderQueue() {
  const list = document.getElementById('queue-list');
  list.innerHTML = '';
  document.getElementById('queue-count').textContent = missionQueue.length;
  missionQueue.forEach((q) => {
    const row = document.createElement('div');
    row.className = `queue-item ${q.status}`;
    row.innerHTML = `<div>${escHtml(q.task)}</div><div class="queue-meta"><span>${q.status.toUpperCase()}</span><span>${q.elapsed ? `${q.elapsed}s` : '‚Äî'}</span></div>`;
    list.appendChild(row);
  });
}

function dispatchNow() {
  const task = document.getElementById('mission-input').value.trim();
  if (!task) return;
  missionQueue.unshift({ id: uid('q'), missionId: uuid(), task, status: 'pending', createdAt: new Date().toISOString(), score: null, elapsed: null, tokens: 0 });
  document.getElementById('mission-input').value = '';
  saveQueue();
  renderQueue();
  if (!running) runNextFromQueue();
}

function updateQueueItem(id, patch) {
  const idx = missionQueue.findIndex((m) => m.id === id);
  if (idx < 0) return;
  missionQueue[idx] = { ...missionQueue[idx], ...patch };
  saveQueue();
  renderQueue();
}

function runNextFromQueue() {
  if (running) return;
  const next = missionQueue.find((m) => m.status === 'pending');
  if (!next) return;
  runMission(next);
}

function setMemoryTab(agent) {
  activeMemoryTab = agent;
  ['atlas','forge','lens'].forEach((a) => document.getElementById(`tab-${a}`).classList.toggle('active', a === agent));
  renderMemory();
}

function renderMemory() {
  const el = document.getElementById('memory-list');
  const items = agentMemory[activeMemoryTab] || [];
  el.innerHTML = items.length ? items.map((x) => {
    if (typeof x === 'string') return `<div class="memory-item"><div>${escHtml(x)}</div></div>`;
    return `<div class="memory-item"><div class="memory-meta">${escHtml(x.ts || '')}${x.mission ? ` ¬∑ ${escHtml(x.mission)}` : ''}</div><div>${escHtml(x.content || '')}</div></div>`;
  }).join('') : '<div style="color:var(--text3)">No lessons.</div>';
}

function clearAgentMemory() {
  agentMemory[activeMemoryTab] = [];
  localStorage.setItem(MEMORY_KEY, JSON.stringify(agentMemory));
  renderMemory();
}

function appendMemory(agent, content, mission='') {
  if (!content) return;
  const arr = agentMemory[agent] || [];
  arr.unshift({ ts: new Date().toISOString().replace('T', ' ').slice(0, 19), content: String(content).slice(0, 220), mission });
  agentMemory[agent] = arr.slice(0, 30);
  localStorage.setItem(MEMORY_KEY, JSON.stringify(agentMemory));
}

async function fetchWithTimeout(url, options = {}, timeout = 5000) {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeout);
  try {
    const resp = await fetch(url, { ...options, signal: controller.signal });
    return resp;
  } finally {
    clearTimeout(timer);
  }
}

async function executeTool(tool, args = {}) {
  const resp = await fetchWithTimeout(`${TOOL_SERVER}/tool`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ tool, args })
  }, 9000);
  return resp.json();
}

function addToolOutput(title, content) {
  toolOutputs += 1;
  document.getElementById('tool-count').textContent = String(toolOutputs);
  const wrap = document.getElementById('tool-output');
  const row = document.createElement('div');
  row.className = 'tool-item';
  row.innerHTML = `<div class="tool-path">${escHtml(title)}</div><div class="tool-code">${escHtml(content).slice(0, 1400)}</div>`;
  wrap.appendChild(row);
  wrap.scrollTop = wrap.scrollHeight;
}

function addToolBadge(text) {
  const wrap = document.getElementById('tool-output');
  const row = document.createElement('div');
  row.className = 'tool-item tool-badge';
  row.textContent = text;
  wrap.appendChild(row);
  wrap.scrollTop = wrap.scrollHeight;
  return row;
}

async function processForgeTools(text) {
  let processed = text;

  const webMatches = [...processed.matchAll(/<TOOL:WEB_SEARCH\s+query="([^"]+)"\/>/g)];
  for (const m of webMatches) {
    const query = m[1];
    const badge = addToolBadge('üîç searching...');
    log('forge', `WEB_SEARCH ${query}`, 'log-tool');
    const result = await executeTool('web_search', { query, count: 5 }).catch(() => ({ success: false, error: 'tool server offline' }));
    const resultCount = Array.isArray(result?.results) ? result.results.length : 0;
    badge.textContent = result.success
      ? `üîç web search: ${query} ‚Üí ${resultCount} results`
      : `üîç web search: ${query} ‚Üí failed`;
    const inject = result.success
      ? `[WEB_SEARCH ${query}]\n${(result.results || []).map((r) => `- ${r.title}: ${r.url}`).join('\n')}`
      : `[WEB_SEARCH failed: ${result.error}]`;
    addToolOutput(`WEB_SEARCH: ${query}`, inject);
    processed = processed.replace(m[0], inject);
  }

  const pyMatches = [...processed.matchAll(/<TOOL:RUN_PYTHON>([\s\S]*?)<\/TOOL>/g)];
  for (const m of pyMatches) {
    const code = (m[1] || '').trim();
    log('forge', 'RUN_PYTHON', 'log-tool');
    const result = await executeTool('run_python', { code, timeout: 20 }).catch(() => ({ success: false, error: 'tool server offline' }));
    const output = result.success ? ((result.stdout || '(no output)') + (result.stderr ? `\nERR:\n${result.stderr}` : '')) : `Error: ${result.error}`;
    addToolOutput('RUN_PYTHON', output);
    processed = processed.replace(m[0], `[RUN_PYTHON OUTPUT]\n${output}`);
  }

  const writeMatches = [...processed.matchAll(/<TOOL:WRITE_FILE\s+path="([^"]+)">([\s\S]*?)<\/TOOL>/g)];
  for (const m of writeMatches) {
    const path = m[1];
    const content = (m[2] || '').trim();
    log('forge', `WRITE_FILE ${path}`, 'log-tool');
    const result = await executeTool('write_file', { path, content }).catch(() => ({ success: false, error: 'tool server offline' }));
    const summary = result.success ? `Saved ${path} (${content.length} chars)` : `Failed ${path}: ${result.error}`;
    addToolOutput(`WRITE_FILE: ${path}`, summary);
  }

  return processed;
}

async function streamAgent(name, messages) {
  const cfg = AGENTS[name];
  const t0 = Date.now();
  let fullText = '';
  let tokens = 0;

  setDot(`dot-${name}`, 'on');

  if (cfg.api === 'ollama') {
    const sys = missionSystemPrompts[name] || cfg.system;
    const userBlock = messages.map((m) => `${m.role}: ${m.content}`).join('\n\n');
    const prompt = `<|im_start|>system\n${sys}<|im_end|>\n<|im_start|>user\n${userBlock}<|im_end|>\n<|im_start|>assistant\n`;

    const resp = await fetchWithTimeout(`${cfg.endpoint}/api/generate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: cfg.model,
        prompt,
        stream: true,
        think: false,
        options: { num_predict: cfg.maxTokens, temperature: cfg.temp, num_ctx: cfg.ctx, top_p: 0.8 }
      })
    }, 60000);

    const reader = resp.body.getReader();
    const dec = new TextDecoder();
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      const lines = dec.decode(value).split('\n').filter((l) => l.trim());
      for (const line of lines) {
        try {
          const obj = JSON.parse(line);
          const chunk = obj.response || '';
          if (chunk) { fullText += chunk; tokens += 1; }
        } catch {}
      }
      setLiveOutput(name, fullText);
      if (abortCtrl?.signal.aborted) throw new DOMException('Aborted', 'AbortError');
    }

  } else {
    const sys = missionSystemPrompts[name] || cfg.system;
    const resp = await fetchWithTimeout(`${cfg.endpoint}/v1/chat/completions`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', Authorization: 'Bearer local' },
      body: JSON.stringify({
        model: cfg.model,
        stream: true,
        messages: [{ role: 'system', content: sys }, ...messages],
        max_tokens: cfg.maxTokens,
        temperature: cfg.temp,
        top_p: 0.8
      })
    }, 60000);

    const reader = resp.body.getReader();
    const dec = new TextDecoder();
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      const lines = dec.decode(value).split('\n').filter((l) => l.startsWith('data:'));
      for (const line of lines) {
        const raw = line.replace(/^data:\s*/, '');
        if (raw === '[DONE]') continue;
        try {
          const delta = JSON.parse(raw).choices?.[0]?.delta || {};
          if (delta.content) { fullText += delta.content; tokens += 1; }
        } catch {}
      }
      setLiveOutput(name, fullText);
      if (abortCtrl?.signal.aborted) throw new DOMException('Aborted', 'AbortError');
    }
  }

  const elapsed = (Date.now() - t0) / 1000;
  return { text: fullText, tokens, elapsed: Number(elapsed.toFixed(1)), tps: elapsed > 0 ? Math.round(tokens / elapsed) : 0 };
}

function parseVerdict(text) {
  try {
    const m = text.match(/\{[\s\S]*\}/);
    if (m) {
      const parsed = JSON.parse(m[0]);
      return {
        verdict: parsed.verdict || 'NO_SHIP',
        score: Number(parsed.score || 0),
        issues: Array.isArray(parsed.issues) ? parsed.issues : [],
        improvements: Array.isArray(parsed.improvements) ? parsed.improvements : [],
        feedback: parsed.feedback || ''
      };
    }
  } catch {}
  return { verdict: 'NO_SHIP', score: 0, issues: ['Could not parse Lens JSON'], improvements: [], feedback: text.slice(0, 180) };
}

async function runMission(queueItem) {
  running = true;
  abortCtrl = new AbortController();
  rebuildMissionPrompts();
  missionStart = Date.now();
  totalTokensCurrent = 0;
  toolOutputs = 0;
  setCodexHandoffAvailability(0, '');
  setHandoffStatus('');
  resetMissionPanels();
  document.getElementById('tool-output').innerHTML = '';
  document.getElementById('tool-count').textContent = '0';
  document.getElementById('btn-dispatch').disabled = true;
  document.getElementById('btn-abort').disabled = false;
  setAgentPresence('atlas', 'idle', 'Queued for planning');
  setAgentPresence('forge', 'idle', 'Queued for implementation');
  setAgentPresence('lens', 'idle', 'Queued for review');
  switchRightTab('live');

  updateQueueItem(queueItem.id, { status: 'running' });
  log('sys', `Mission started: ${queueItem.task}`, 'log-sys');
  setLiveOutput('system', `Mission started\n\n${queueItem.task}`);

  const atlas = { text: '', tokens: 0, elapsed: 0 };
  let forge = { text: '', tokens: 0, elapsed: 0 };
  let lens = { text: '', tokens: 0, elapsed: 0 };
  let verdict = null;

  try {
    if (mode !== 'forge-only') {
      log('atlas', 'Planning', 'log-atlas');
      setAgentPresence('atlas', 'thinking', 'Planning mission');
      const r = await streamAgent('atlas', [{ role: 'user', content: queueItem.task }]);
      atlas.text = r.text;
      atlas.tokens = r.tokens;
      atlas.elapsed = r.elapsed;
      atlas.tps = r.tps;
      totalTokensCurrent += r.tokens;
      appendMemory('atlas', `Planned mission, ${r.tokens} tokens`, queueItem.task.slice(0, 50));
      setLiveOutput('atlas', atlas.text);
      setAgentPresence('atlas', 'idle', `Plan ready ¬∑ ${r.elapsed}s`, r);
    }

    if (mode !== 'atlas-only') {
      log('forge', 'Building', 'log-forge');
      setAgentPresence('forge', 'thinking', 'Building output');
      const user = mode === 'forge-only'
        ? queueItem.task
        : `Task:\n${queueItem.task}\n\nAtlas Plan:\n${atlas.text}`;
      const r = await streamAgent('forge', [{ role: 'user', content: user }]);
      setLiveOutput('forge', r.text);
      setAgentPresence('forge', 'working', 'Running tool actions', r);
      forge = { text: await processForgeTools(r.text), tokens: r.tokens, elapsed: r.elapsed, tps: r.tps };
      totalTokensCurrent += r.tokens;
      appendMemory('forge', `Built mission, ${r.tokens} tokens`, queueItem.task.slice(0, 50));
      setLiveOutput('forge', forge.text);
      setAgentPresence('forge', 'idle', `Output ready ¬∑ ${r.elapsed}s`, r);

      if (mode === 'full') {
        log('lens', 'Reviewing', 'log-lens');
        setAgentPresence('lens', 'thinking', 'Reviewing forge output');
        const lr = await streamAgent('lens', [{ role: 'user', content: `Task:\n${queueItem.task}\n\nForge Output:\n${forge.text.slice(0, 3500)}` }]);
        lens = lr;
        lens.tps = lr.tps;
        verdict = parseVerdict(lr.text);
        totalTokensCurrent += lr.tokens;
        appendMemory('lens', `${verdict.verdict} ${verdict.score}/10`, queueItem.task.slice(0, 50));
        setLiveOutput('lens', lr.text);
        setAgentPresence('lens', 'idle', `${verdict.verdict} ¬∑ ${lr.elapsed}s`, lr);
      }
    }

    const elapsed = Number(((Date.now() - missionStart) / 1000).toFixed(1));
    const score = verdict ? verdict.score : 0;
    const missionRecord = {
      id: queueItem.missionId || uuid(),
      task: queueItem.task,
      date: new Date().toISOString().slice(0, 10),
      ts: new Date().toISOString(),
      atlas: atlas.text,
      forge: forge.text,
      lens: lens.text,
      verdict,
      score,
      tokens: totalTokensCurrent,
      elapsed
    };

    await persistMission(missionRecord);
    localMissions.unshift(missionRecord);
    localMissions = localMissions.slice(0, 200);
    localStorage.setItem(HISTORY_KEY, JSON.stringify(localMissions));

    updateQueueItem(queueItem.id, { status: 'done', score, elapsed, tokens: totalTokensCurrent });
    setCodexHandoffAvailability(score, forge.text);
    log('sys', `Mission complete: ${score}/10 ¬∑ ${totalTokensCurrent} tokens ¬∑ ${elapsed}s`, 'log-sys');
    renderMissionReport({
      verdict: verdict?.verdict || 'SHIP',
      elapsed,
      timestamp: new Date().toLocaleString(),
      agentStats: [
        { agent: 'Atlas', tokens: atlas.tokens || 0, tps: atlas.tps || 0, time: `${atlas.elapsed || 0}s` },
        { agent: 'Forge', tokens: forge.tokens || 0, tps: forge.tps || 0, time: `${forge.elapsed || 0}s` },
        { agent: 'Lens', tokens: lens.tokens || 0, tps: lens.tps || 0, time: `${lens.elapsed || 0}s` }
      ],
      forgeOutput: forge.text || '',
      issues: verdict?.issues || []
    });
    switchRightTab('report');
    await loadMissions();

  } catch (err) {
    if (err?.name === 'AbortError') {
      updateQueueItem(queueItem.id, { status: 'failed' });
      log('sys', 'Mission aborted', 'log-err');
      renderMissionReport({
        verdict: 'NO_SHIP',
        elapsed: Number(((Date.now() - missionStart) / 1000).toFixed(1)),
        timestamp: new Date().toLocaleString(),
        agentStats: [
          { agent: 'Atlas', tokens: atlas.tokens || 0, tps: atlas.tps || 0, time: `${atlas.elapsed || 0}s` },
          { agent: 'Forge', tokens: forge.tokens || 0, tps: forge.tps || 0, time: `${forge.elapsed || 0}s` },
          { agent: 'Lens', tokens: lens.tokens || 0, tps: lens.tps || 0, time: `${lens.elapsed || 0}s` }
        ],
        forgeOutput: forge.text || '',
        issues: ['Mission aborted before completion']
      });
      switchRightTab('report');
    } else {
      updateQueueItem(queueItem.id, { status: 'failed' });
      log('sys', `Mission failed: ${err.message || err}`, 'log-err');
      renderMissionReport({
        verdict: 'NO_SHIP',
        elapsed: Number(((Date.now() - missionStart) / 1000).toFixed(1)),
        timestamp: new Date().toLocaleString(),
        agentStats: [
          { agent: 'Atlas', tokens: atlas.tokens || 0, tps: atlas.tps || 0, time: `${atlas.elapsed || 0}s` },
          { agent: 'Forge', tokens: forge.tokens || 0, tps: forge.tps || 0, time: `${forge.elapsed || 0}s` },
          { agent: 'Lens', tokens: lens.tokens || 0, tps: lens.tps || 0, time: `${lens.elapsed || 0}s` }
        ],
        forgeOutput: forge.text || '',
        issues: [String(err.message || err)]
      });
      switchRightTab('report');
    }
  } finally {
    running = false;
    abortCtrl = null;
    document.getElementById('btn-dispatch').disabled = false;
    document.getElementById('btn-abort').disabled = true;
    localStorage.setItem(MEMORY_KEY, JSON.stringify(agentMemory));
    renderMemory();
    renderQueue();
    runNextFromQueue();
  }
}

async function persistMission(mission) {
  let savedRemote = false;
  try {
    const payload = {
      id: mission.id || uuid(),
      task: mission.task || '',
      date: mission.date || new Date().toISOString().slice(0, 10),
      atlas: mission.atlas || '',
      forge: mission.forge || '',
      lens: mission.lens || '',
      score: Number(mission.score || mission.verdict?.score || 0),
      tokens: Number(mission.tokens || 0),
      elapsed: Number(mission.elapsed || 0)
    };
    const resp = await fetchWithTimeout(`${TOOL_SERVER}/tool`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ tool: 'save_mission', mission: payload })
    }, 9000);
    const data = await resp.json();
    savedRemote = Boolean(data.success);
  } catch {}
  if (!savedRemote) {
    log('sys', 'Tool server unreachable, mission persisted to localStorage fallback', 'log-err');
  }
}

async function loadMissions() {
  let remote = [];
  try {
    const resp = await fetchWithTimeout(`${TOOL_SERVER}/missions`, {}, 9000);
    const data = await resp.json();
    remote = Array.isArray(data.missions) ? data.missions : [];
  } catch {}

  const merged = new Map();
  [...localMissions, ...remote].forEach((m) => {
    const key = m.id || `${m.date}-${slugify(m.task || '')}`;
    if (!merged.has(key)) merged.set(key, m);
  });

  allMissions = [...merged.values()].sort((a, b) => new Date(b.ts || b._saved_at || b.date || 0) - new Date(a.ts || a._saved_at || a.date || 0));
  renderHistory();
  updateTopStats();
}

function scoreClass(score) {
  if (score >= 8) return 'high';
  if (score >= 6) return 'mid';
  return 'low';
}

function renderHistory() {
  const list = document.getElementById('history-list');
  const q = document.getElementById('history-filter').value.trim().toLowerCase();
  list.innerHTML = '';
  const filtered = allMissions.filter((m) => {
    if (!q) return true;
    const hay = `${m.task || ''} ${m.verdict?.verdict || ''} ${m.score || ''} ${(m.lens || '').slice(0, 300)}`.toLowerCase();
    return hay.includes(q);
  });
  document.getElementById('history-count').textContent = String(filtered.length);

  filtered.forEach((m) => {
    const row = document.createElement('div');
    row.className = 'history-item';
    const score = Number(m.score || m.verdict?.score || 0);
    row.innerHTML = `<div class="history-title">${escHtml((m.task || '').slice(0, 80))}</div>
      <div class="history-meta"><span>${escHtml(m.date || (m.ts || '').slice(0, 10) || '‚Äî')}</span><span>${m.tokens || 0} tok</span><span>${m.elapsed || '‚Äî'}s</span><span class="badge ${scoreClass(score)}">${score}/10</span></div>`;
    row.onclick = () => openMissionDetail(m);
    list.appendChild(row);
  });
}

function recommendation(m) {
  const score = Number(m.score || m.verdict?.score || 0);
  if ((m.verdict?.verdict || '') === 'SHIP' || score >= 8) return 'SHIP IT';
  if (score >= 6) return 'NEEDS WORK';
  return 'RETRY';
}

function highlightCode(text) {
  let code = escHtml(text || '(none)');
  code = code.replace(/(\/\*[^]*?\*\/|\/\/.*$)/gm, '<span class="code-cmt">$1</span>');
  code = code.replace(/("(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')/g, '<span class="code-str">$1</span>');
  code = code.replace(/\b(function|const|let|var|return|if|else|for|while|async|await|class|import|from|export|try|catch|finally|new|def|print)\b/g, '<span class="code-kw">$1</span>');
  code = code.replace(/\b(\d+)\b/g, '<span class="code-num">$1</span>');
  return code;
}

function openMissionDetail(mission) {
  selectedMission = mission;
  document.getElementById('detail-title').textContent = mission.task || 'Mission';
  const score = Number(mission.score || mission.verdict?.score || 0);
  document.getElementById('detail-summary').innerHTML = `Date: ${escHtml(mission.date || (mission.ts || '').slice(0,10) || '‚Äî')} | Score: <span class="badge ${scoreClass(score)}">${score}/10</span> | Tokens: ${mission.tokens || 0} | Recommendation: <strong>${recommendation(mission)}</strong>`;
  document.getElementById('detail-atlas').textContent = mission.atlas || '(none)';
  document.getElementById('detail-forge').innerHTML = highlightCode(mission.forge || '(none)');
  const lensBlock = mission.verdict
    ? JSON.stringify(mission.verdict, null, 2)
    : (mission.lens || '(none)');
  document.getElementById('detail-lens').textContent = lensBlock;
  document.getElementById('detail-modal').classList.add('open');
}

function closeMissionDetail() {
  document.getElementById('detail-modal').classList.remove('open');
}

function copyForgeOutput() {
  const txt = document.getElementById('detail-forge').textContent;
  navigator.clipboard.writeText(txt).catch(() => {});
}

function exportToCodex() {
  if (!selectedMission) return;
  const m = selectedMission;
  const score = Number(m.score || m.verdict?.score || 0);
  const issues = (m.verdict?.issues || []).length ? (m.verdict.issues || []).map((i) => `- ${i}`).join('\n') : '- none';
  const out = `# PC1 Mission ‚Äî ${m.task || 'Untitled'}\nDate: ${m.date || (m.ts || '').slice(0,10) || '‚Äî'} | Score: ${score}/10 | Tokens: ${m.tokens || 0}\n\n## Atlas Plan\n${m.atlas || '(none)'}\n\n## Forge Output\n${m.forge || '(none)'}\n\n## Lens Verdict\n${m.verdict ? `${m.verdict.verdict} (${score}/10)\n${m.verdict.feedback || ''}` : (m.lens || '(none)')}\nIssues:\n${issues}\n\n## Codex Instructions\nIntegrate into ClawSuite. Fix Lens issues. Run tsc --noEmit.\nCommit: "feat: ${slugify(m.task).replace(/-/g, ' ')} [PC1]"`;
  navigator.clipboard.writeText(out).then(() => log('sys', 'Exported mission markdown to clipboard', 'log-sys'));
}

async function runCodexHandoff() {
  if (lastMissionScore < 7 || !lastForgeSummary) {
    setHandoffStatus('Needs revision ‚Äî retry?');
    return;
  }
  const btn = document.getElementById('btn-codex-handoff');
  btn.disabled = true;
  setHandoffStatus('Codex running...');
  const quoted = lastForgeSummary.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  const command = `cd /mnt/c/Users/eric/clawsuite && codex exec --model gpt-5.3-codex --full-auto --skip-git-repo-check "${quoted}"`;
  try {
    const resp = await fetchWithTimeout(`${TOOL_SERVER}/tool`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ tool: 'run_shell', command })
    }, 120000);
    const data = await resp.json();
    const output = [data.stdout, data.stderr, data.result, data.error].filter(Boolean).join('\n').slice(0, 4000);
    setHandoffStatus(output || (data.success ? 'Codex run finished.' : 'Codex run failed.'));
  } catch (err) {
    setHandoffStatus(`Codex handoff failed: ${err.message || err}`);
  } finally {
    btn.disabled = false;
  }
}

function rerunMission() {
  if (!selectedMission) return;
  document.getElementById('mission-input').value = selectedMission.task || '';
  closeMissionDetail();
  dispatchNow();
}

function abortMission() {
  if (abortCtrl) abortCtrl.abort();
}

async function loadAgentMemoryFile() {
  try {
    const resp = await fetchWithTimeout('agent-memory.json', {}, 4000);
    if (!resp.ok) throw new Error('memory file unavailable');
    const json = await resp.json();
    if (json && typeof json === 'object') {
      agentMemory = {
        atlas: normalizeLessons(json.atlas),
        forge: normalizeLessons(json.forge),
        lens: normalizeLessons(json.lens)
      };
      localStorage.setItem(MEMORY_KEY, JSON.stringify(agentMemory));
    }
  } catch {}
  rebuildMissionPrompts();
  renderMemory();
}

async function updateEndpointHealth() {
  setToolStatus('checking');
  let pc1Ok = false;
  let pc2Ok = false;
  let toolOk = false;

  try {
    const r = await fetchWithTimeout(`${PC1_ENDPOINT}/health`, {}, 3500);
    pc1Ok = r.ok;
  } catch {}

  try {
    const r = await fetchWithTimeout(`${PC2_ENDPOINT}/api/tags`, {}, 3500);
    pc2Ok = r.ok;
  } catch {}

  try {
    const r = await fetchWithTimeout(`${TOOL_SERVER}/health`, {}, 3500);
    toolOk = r.ok;
  } catch {}

  setDot('dot-pc1', pc1Ok ? 'on' : 'off');
  setDot('dot-pc2', pc2Ok ? 'on' : 'off');
  setDot('dot-forge', pc1Ok ? 'on' : 'off');
  setDot('dot-atlas', pc2Ok ? 'on' : 'off');
  setDot('dot-lens', pc2Ok ? 'on' : 'off');

  document.getElementById('pc1-text').textContent = pc1Ok ? '‚óè connected' : '‚óã offline';
  document.getElementById('pc2-text').textContent = pc2Ok ? '‚óè connected' : '‚óã offline';
  setToolStatus(toolOk ? 'connected' : 'offline');
}

function updateTopStats() {
  const scored = allMissions.map((m) => Number(m.score || m.verdict?.score || 0)).filter((n) => n > 0);
  const avg = scored.length ? (scored.reduce((a, b) => a + b, 0) / scored.length).toFixed(1) : '‚Äî';
  const tokens = allMissions.reduce((sum, m) => sum + Number(m.tokens || 0), 0);
  const up = Math.floor((Date.now() - startedAt) / 1000);
  document.getElementById('stats-line').innerHTML = `<span>Total: ${allMissions.length}</span><span>Avg: ${avg}</span><span>Tokens: ${tokens}</span><span>Uptime: ${up}s</span>`;
}

document.getElementById('mission-input').addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    dispatchNow();
  }
});

document.getElementById('queue-input').addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    addMissionToQueue('queue-input');
  }
});

async function boot() {
  renderQueue();
  renderMemory();
  renderTeamPanel();
  resetMissionPanels();
  await loadAgentMemoryFile();
  await updateEndpointHealth();
  await loadMissions();
  runNextFromQueue();
  setInterval(updateEndpointHealth, 10000);
  setInterval(updateTopStats, 10000);
  log('sys', 'Mission Control v5 online', 'log-sys');
}

boot();
</script>
</body>
</html>
